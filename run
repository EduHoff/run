#!/usr/bin/env bash

# -------------------
# Utility functions
# -------------------

find_cargo_toml() {
    local current_dir=$(dirname "$(realpath "$1")")
    while [ "$current_dir" != "/" ] && [ -n "$current_dir" ]; do
        if [ -f "$current_dir/Cargo.toml" ]; then
            echo "$current_dir/Cargo.toml"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done
    return 1
}

# Detect the main class in a Java project
detect_main_class() {
    local root_dir="$1"
    local candidates=()

    while IFS= read -r file; do
        if grep -q "public[[:space:]]\+static[[:space:]]\+void[[:space:]]\+main" "$file"; then
            local pkg=$(grep "^package " "$file" | sed 's/package \(.*\);/\1/' || true)
            local cls=$(basename "$file" .java)
            if [ -n "$pkg" ]; then
                candidates+=("$pkg.$cls")
            else
                candidates+=("$cls")
            fi
        fi
    done < <(find "$root_dir" -name "*.java")

    if [ ${#candidates[@]} -eq 0 ]; then
        echo "Error: No class with main method found." >&2
        return 1
    elif [ ${#candidates[@]} -eq 1 ]; then
        echo "${candidates[0]}"
    else
        echo "Multiple classes with main method found:"
        for i in "${!candidates[@]}"; do
            echo "[$((i+1))] ${candidates[$i]}"
        done
        read -p "Choose the main class (number): " choice
        local index=$((choice-1))
        if [ -n "${candidates[$index]}" ]; then
            echo "${candidates[$index]}"
        else
            echo "Invalid choice." >&2
            return 1
        fi
    fi
}

# -------------------
# Compile
# -------------------
compile(){
    local file="$1"
    local ext="$2"
    local file_name="$3"

    case "$ext" in
        "c") gcc "$file" -o "$file_name" ;;
        "cpp") g++ "$file" -o "$file_name" ;;
        "cs")
            if compgen -G "*.csproj" > /dev/null; then
                dotnet build
            else
                echo "Error: C# requires a .csproj project file." >&2
                return 1
            fi
            ;;
        "csproj") dotnet build ;;
        "hs") ghc "$file" -o "$file_name" ;;
        "rs")
            local cargo_toml=$(find_cargo_toml "$file")
            if [ -n "$cargo_toml" ]; then
                (cd "$(dirname "$cargo_toml")" && cargo build)
            else
                rustc "$file"
            fi
            ;;
        "go")
            if [ "$compile_flag" = true ]; then
                go build -o "$file_name" "$file"
            fi
            ;;
        "ts") [ "$compile_flag" = true ] && tsc "$file" ;;
        "jar")
            echo "JAR file detected. Nothing to compile." ;;
        "java" | "class")
            echo "Error: Java requires the --java flag. Use: run --java <root_dir>" >&2
            return 1
            ;;
        *)
            [ "$compile_flag" = true ] && echo "Error: File '$file' is not compilable." >&2 && return 1
            ;;
    esac
}

# -------------------
# Execute
# -------------------
execute(){
    local file="$1"
    local ext="$2"
    local file_name="$3"

    case "$ext" in
        "c" | "cpp" | "hs") ./"$file_name" ;;
        "cs" | "csproj") dotnet run --no-build ;;
        "rs")
            local cargo_toml=$(find_cargo_toml "$file")
            if [ -n "$cargo_toml" ]; then
                (cd "$(dirname "$cargo_toml")" && cargo run)
            else
                ./"$file_name"
            fi
            ;;
        "go")
            if [ "$compile_flag" = true ]; then
                ./"$file_name"
            else
                go run "$file"
            fi
            ;;
        "js" | "ts" | "py" | "rb" | "sh" | "lua" | "php") interpreter "$file" "$ext" ;;
        "jar") java -jar "$file" ;;
        "java" | "class")
            echo "Error: Java requires the --java flag. Use: run --java <root_dir>" >&2
            return 1run 
            ;;
        *)
            if [ -x "$file" ]; then
                ./"$file_name"
            else
                echo "Error: Could not execute '$file'. Unsupported file type or not executable." >&2
                return 1
            fi            
    esac
}

# -------------------
# Interpreter
# -------------------
interpreter(){
    local file="$1"
    local ext="$2"
    case "$ext" in
        "hs") runhaskell "$file" ;;
        "js" | "ts") node "$file" ;;
        "py") python3 "$file" ;;
        "rb") ruby "$file" ;;
        "lua") lua "$file" ;;
        "php") php "$file" ;;
        "sh") ./"$file" ;;
        "java" | "class" | "jar")
            echo "Error: Java requires the --java flag. Use: run --java <root_dir>" >&2
            exit 1
            ;;
        *) echo "Error: '$ext' is not an interpreted language." >&2; exit 1 ;;
    esac
}

# -------------------
# Java: compile & execute
# -------------------

compile_java(){
    local root_dir="$1"

    if [ -f "$root_dir/pom.xml" ]; then
        echo "Maven project detected. Compiling with mvn..."
        (cd "$root_dir" && mvn package)
    elif compgen -G "$root_dir/build.gradle*" > /dev/null; then
        echo "Gradle project detected. Compiling with gradle..."
        (cd "$root_dir" && gradle build)
    else
        echo "Manual Java project detected. Compiling all .java files..."
        find "$root_dir" -name "*.java" > sources.txt
        if [ -s sources.txt ]; then
            mkdir -p "$root_dir/bin"
            javac -d "$root_dir/bin" @sources.txt
            local entry_point
            entry_point=$(detect_main_class "$root_dir") || return 1
            local simple_name=$(basename "$entry_point")
            local jar_name="$root_dir/$simple_name.jar"

            # Detecta dependências (em lib/ ou no diretório raiz)
            local deps=()
            if compgen -G "$root_dir/lib/*.jar" > /dev/null; then
                for dep in "$root_dir/lib/"*.jar; do
                    deps+=("$(basename "$dep")")
                done
            elif compgen -G "$root_dir/*.jar" > /dev/null; then
                for dep in "$root_dir/"*.jar; do
                    [ "$dep" != "$jar_name" ] && deps+=("$(basename "$dep")")
                done
            fi

            # Se não encontrou nada, pergunta para o usuário
            if [ ${#deps[@]} -eq 0 ]; then
                read -p "Nenhuma biblioteca encontrada. Digite o caminho para procurar JARs (ou deixe vazio para ignorar): " lib_path
                if [ -n "$lib_path" ] && compgen -G "$lib_path/*.jar" > /dev/null; then
                    for dep in "$lib_path"/*.jar; do
                        deps+=("$(basename "$dep")")
                        # Copia para o projeto (assim o jar funciona sozinho depois)
                        cp "$dep" "$root_dir/"
                    done
                fi
            fi

            # Monta manifest com Main-Class e dependências
            {
                echo "Main-Class: $entry_point"
                if [ ${#deps[@]} -gt 0 ]; then
                    echo -n "Class-Path: "
                    printf "%s " "${deps[@]}"
                    echo
                fi
            } > "$root_dir/manifest.txt"

            # Cria JAR
            jar cfm "$jar_name" "$root_dir/manifest.txt" -C "$root_dir/bin" .

            rm sources.txt "$root_dir/manifest.txt"
            echo "Created JAR: $jar_name (entry point: $entry_point)"
        else
            echo "Error: No .java files found in $root_dir." >&2
            rm sources.txt
            return 1
        fi
    fi
}



execute_java(){
    local root_dir="$1"

    if [ -f "$root_dir/pom.xml" ]; then
        echo "Running Maven project..."
        (cd "$root_dir" && mvn exec:java)
    elif compgen -G "$root_dir/build.gradle*" > /dev/null; then
        echo "Running Gradle project..."
        (cd "$root_dir" && gradle run)
    else
        local jar_file=$(find "$root_dir" -maxdepth 1 -name "*.jar" | head -n 1)
        if [ -n "$jar_file" ]; then
            echo "Running JAR: $jar_file"
            local cp="$jar_file"
            if compgen -G "$root_dir/lib/*.jar" > /dev/null; then
                cp="$cp:$root_dir/lib/*"
            elif compgen -G "$root_dir/*.jar" > /dev/null; then
                cp="$cp:$root_dir/*.jar"
            fi
            java -cp "$cp" -jar "$jar_file"
        else
            echo "Error: No JAR found. Compile first with -c." >&2
            return 1
        fi
    fi
}

interpret_java(){
    local root_dir="$1"
    echo "Running Java classes directly..."
    local entry_point
    entry_point=$(detect_main_class "$root_dir") || return 1

    local cp="$root_dir/bin"
    if compgen -G "$root_dir/lib/*.jar" > /dev/null; then
        cp="$cp:$root_dir/lib/*"
    elif compgen -G "$root_dir/*.jar" > /dev/null; then
        cp="$cp:$root_dir/*.jar"
    fi

    java -cp "$cp" "$entry_point"
}


# -------------------
# Flags
# -------------------
compile_flag=false
execute_flag=false
interpreter_flag=false
java_flag=false
java_root=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -c) compile_flag=true; shift ;;
        -e) execute_flag=true; shift ;;
        -i) interpreter_flag=true; shift ;;
        --java) java_flag=true; shift; java_root="$1"; shift ;;
        *) break ;;
    esac
done

# -------------------
# Java execution
# -------------------
if [ "$java_flag" = true ]; then
    if [ -z "$java_root" ]; then
        echo "Error: No Java root directory provided." >&2
        exit 1
    fi

    [ "$compile_flag" = true ] && compile_java "$java_root"
    [ "$execute_flag" = true ] && execute_java "$java_root"
    [ "$interpreter_flag" = true ] && interpret_java "$java_root"

    if [ "$compile_flag" = false ] && [ "$execute_flag" = false ] && [ "$interpreter_flag" = false ]; then
        compile_java "$java_root" && execute_java "$java_root"
    fi
    exit $?
fi

# -------------------
# Normal execution
# -------------------
if [ -z "$1" ]; then
    echo "Error: No input file provided." >&2
    exit 1
fi

file="$1"
ext="${file##*.}"
file_name=$(basename "$file" ."$ext")

if [ "$compile_flag" = false ] && [ "$execute_flag" = false ] && [ "$interpreter_flag" = false ]; then
    compile "$file" "$ext" "$file_name"
    execute "$file" "$ext" "$file_name"
    exit $?
fi
[ "$compile_flag" = true ] && compile "$file" "$ext" "$file_name" && exit $?
[ "$execute_flag" = true ] && execute "$file" "$ext" "$file_name" && exit $?
[ "$interpreter_flag" = true ] && interpreter "$file" "$ext" && exit $?

