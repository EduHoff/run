#!/usr/bin/env bash

find_cargo_toml() {
    local current_dir=$(dirname "$(realpath "$1")")
    
    while [ "$current_dir" != "/" ] && [ -n "$current_dir" ]; do
        if [ -f "$current_dir/Cargo.toml" ]; then
            echo "$current_dir/Cargo.toml"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
        if [ ${#current_dir} -lt 2 ]; then
            break
        fi
    done
    return 1
}

compile(){
    local file="$1"
    local ext="$2"
    local file_name="$3"

    case "$ext" in
        "c") #C
            gcc "$file" -o "$file_name"
            ;;
        "cpp") #C++
            g++ "$file" -o "$file_name"
            ;;
        "cs") #C# arquivo individual
            if compgen -G "*.csproj" > /dev/null; then
                dotnet build
            else
                echo "Error: C# requires a .csproj project file." >&2
                return 1
            fi
            ;;
        "csproj") #C# projeto
            dotnet build
            ;;
        "hs") #Haskell
            ghc "$file" -o "$file_name"
            ;;
        "rs") #Rust
            local cargo_toml=$(find_cargo_toml "$file")
            if [ -n "$cargo_toml" ] && [ -f "$cargo_toml" ]; then
                local project_dir=$(dirname "$cargo_toml")
                (cd "$project_dir" && cargo build)
            else
                rustc "$file"
            fi
            ;;
        "ts") #Typescript (to Javascript)
            if [ "$compile_flag" = true ]; then
                tsc "$file"
            fi
            ;;
        "js" | "py" | "sh") #Interpreter only languages
            if [ "$compile_flag" = true ]; then
                echo "Error: File '$file' is interpreted and cannot be compiled." >&2
                return 1
            fi
            ;;
        *)  
            if [ "$compile_flag" = true ]; then
                echo "Error: File '$file' is not compilable." >&2
                return 1
            fi
            ;;
    esac
}

execute(){
    local file="$1"
    local ext="$2"
    local file_name="$3"

    case "$ext" in
        "c" | "cpp" | "hs") #C, C++, Haskell
            ./"$file_name"
            ;;
        "cs" | "csproj") #Csharp
            dotnet run --no-build
            ;;
        "rs") #Rust - ÃšNICO caso para Rust
            local cargo_toml=$(find_cargo_toml "$file")
            if [ -n "$cargo_toml" ] && [ -f "$cargo_toml" ]; then
                local project_dir=$(dirname "$cargo_toml")
                echo "Running Cargo project: $project_dir"
                (cd "$project_dir" && cargo run)
            else
                ./"$file_name"
            fi
            ;;
        "py" | "js" | "ts" | "sh") #Interpreter only languages
            interpreter "$file" "$ext" "$file_name"
            ;;
        *)  
            if [ -x "$file" ]; then
                ./"$file_name"
            else
                echo "Error: Unknown or unsupported file type '$ext'." >&2
                exit 1
            fi
            ;;
    esac
}

interpreter(){
    local file="$1"
    local ext="$2"
    local file_name="$3"

    case "$ext" in
        "hs") #Haskell
            runhaskell "$file"
            ;;
        "js" | "ts") #Javascript, Typescript
            node "$file"
            ;;
        "py") #Python
            python3 "$file"
            ;;
        "sh") #Shell script
            ./"$file"
            ;;
        *)  
            if [ -x "$file" ]; then
                ./"$file_name"
            else
                echo "Error: '$ext' is not an interpreted language." >&2
                exit 1
            fi
            ;;
    esac
}

# -------------------
# process flags
# -------------------
compile_flag=false
execute_flag=false
interpreter_flag=false

while getopts ":cei" opt; do
    case $opt in
        c) compile_flag=true ;;
        e) execute_flag=true ;;
        i) interpreter_flag=true ;;
        \?) echo "Error: Invalid option '-$OPTARG'." >&2; exit 1 ;;
    esac
done

shift $((OPTIND - 1))

if [ -z "$1" ]; then
    echo "Error: No input file provided." >&2
    exit 1
fi

file="$1"
ext="${file##*.}"
file_name=$(basename "$file" ."$ext")

#default behavior (compile + execute)
if [ "$compile_flag" = false ] && [ "$execute_flag" = false ] && [ "$interpreter_flag" = false ]; then
    compile "$file" "$ext" "$file_name" && execute "$file" "$ext" "$file_name"
    exit $?
fi

#compile only
if [ "$compile_flag" = true ]; then
    compile "$file" "$ext" "$file_name"
    exit $?
fi

#execute only
if [ "$execute_flag" = true ]; then
    execute "$file" "$ext" "$file_name"
    exit $?
fi

#interpreter only
if [ "$interpreter_flag" = true ]; then
    interpreter "$file" "$ext" "$file_name"
    exit $?
fi
