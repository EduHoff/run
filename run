#!/usr/bin/env bash

find_cargo_toml() {
    local current_dir=$(dirname "$(realpath "$1")")
    while [ "$current_dir" != "/" ] && [ -n "$current_dir" ]; do
        if [ -f "$current_dir/Cargo.toml" ]; then
            echo "$current_dir/Cargo.toml"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done
    return 1
}

find_pom_xml() {
    local current_dir=$(dirname "$(realpath "$1")")
    while [ "$current_dir" != "/" ] && [ -n "$current_dir" ]; do
        if [ -f "$current_dir/pom.xml" ]; then
            echo "$current_dir/pom.xml"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done
    return 1
}

find_java_project_root() {
    local current_dir=$(dirname "$(realpath "$1")")
    while [ "$current_dir" != "/" ] && [ -n "$current_dir" ]; do
        if [ -d "$current_dir/src" ]; then
            echo "$current_dir"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done
    return 1
}


# -------------------
# Compilar
# -------------------
compile(){
    local file="$1"
    local ext="$2"
    local file_name="$3"

    case "$ext" in
        "c") gcc "$file" -o "$file_name" ;;
        "cpp") g++ "$file" -o "$file_name" ;;
        "cs")
            if compgen -G "*.csproj" > /dev/null; then
                dotnet build
            else
                echo "Error: C# requires a .csproj project file." >&2
                return 1
            fi
            ;;
        "csproj") dotnet build ;;
        "hs") ghc "$file" -o "$file_name" ;;
        "rs")
            local cargo_toml=$(find_cargo_toml "$file")
            if [ -n "$cargo_toml" ]; then
                local project_dir=$(dirname "$cargo_toml")
                (cd "$project_dir" && cargo build)
            else
                rustc "$file"
            fi
            ;;
        "java")
            local pom_xml=$(find_pom_xml "$file")
            if [ -n "$pom_xml" ]; then
                local project_dir=$(dirname "$pom_xml")
                (cd "$project_dir" && mvn -q package)
            else
                local project_root=$(find_java_project_root "$file")
                if [ -n "$project_root" ]; then
                    # Projeto estilo Eclipse (com src e bin)
                    local bin_dir="$project_root/bin"
                    mkdir -p "$bin_dir"

                    find "$project_root/src" -type f -name "*.java" -print0 | xargs -0 javac -d "$bin_dir"

                    local main_class=$(basename "$file" .java)
                    local package=$(grep -m1 '^package ' "$file" | sed 's/package \(.*\);/\1/')

                    if [ -n "$package" ]; then
                        main_class="$package.$main_class"
                    fi

                    echo "Main-Class: $main_class" > "$bin_dir/manifest.txt"
                    jar cfm "$file_name.jar" "$bin_dir/manifest.txt" -C "$bin_dir" .
                else
                    # Arquivo Java isolado (sem projeto)
                    local bin_dir="./bin"
                    mkdir -p "$bin_dir"

                    javac -d "$bin_dir" "$file"

                    local main_class=$(basename "$file" .java)
                    echo "Main-Class: $main_class" > "$bin_dir/manifest.txt"
                    jar cfm "$file_name.jar" "$bin_dir/manifest.txt" -C "$bin_dir" .
                fi
            fi
            ;;

        "ts") if [ "$compile_flag" = true ]; then tsc "$file"; fi ;;
        "js" | "py" | "sh")
            if [ "$compile_flag" = true ]; then
                echo "Error: File '$file' is interpreted and cannot be compiled." >&2
                return 1
            fi
            ;;
        *)
            if [ "$compile_flag" = true ]; then
                echo "Error: File '$file' is not compilable." >&2
                return 1
            fi
            ;;
    esac
}


# -------------------
# Executar
# -------------------
execute(){
    local file="$1"
    local ext="$2"
    local file_name="$3"

    case "$ext" in
        "c" | "cpp" | "hs") ./"$file_name" ;;
        "cs" | "csproj") dotnet run --no-build ;;
        "rs")
            local cargo_toml=$(find_cargo_toml "$file")
            if [ -n "$cargo_toml" ]; then
                local project_dir=$(dirname "$cargo_toml")
                (cd "$project_dir" && cargo run)
            else
                ./"$file_name"
            fi
            ;;
        "java" | "jar")
            if [ -f "$file_name.jar" ]; then
                java -jar "$file_name.jar"
            else
                echo "Error: No .jar file found for '$file'." >&2
                return 1
            fi
            ;;
        "py" | "js" | "ts" | "sh") interpreter "$file" "$ext" "$file_name" ;;
        *)
            if [ -x "$file" ]; then
                ./"$file_name"
            else
                echo "Error: Unknown or unsupported file type '$ext'." >&2
                exit 1
            fi
            ;;
    esac
}



# -------------------
# Interpretar
# -------------------
interpreter(){
    local file="$1"
    local ext="$2"
    case "$ext" in
        "hs") runhaskell "$file" ;;
        "js" | "ts") node "$file" ;;
        "py") python3 "$file" ;;
        "sh") ./"$file" ;;
        *) echo "Error: '$ext' is not an interpreted language." >&2; exit 1 ;;
    esac
}

# -------------------
# process flags
# -------------------
compile_flag=false
execute_flag=false
interpreter_flag=false

while getopts ":cei" opt; do
    case $opt in
        c) compile_flag=true ;;
        e) execute_flag=true ;;
        i) interpreter_flag=true ;;
        \?) echo "Error: Invalid option '-$OPTARG'." >&2; exit 1 ;;
    esac
done

shift $((OPTIND - 1))

if [ -z "$1" ]; then
    echo "Error: No input file provided." >&2
    exit 1
fi

file="$1"
ext="${file##*.}"
file_name=$(basename "$file" ."$ext")

if [ "$compile_flag" = false ] && [ "$execute_flag" = false ] && [ "$interpreter_flag" = false ]; then
    compile "$file" "$ext" "$file_name" && execute "$file" "$ext" "$file_name"
    exit $?
fi
if [ "$compile_flag" = true ]; then compile "$file" "$ext" "$file_name"; exit $?; fi
if [ "$execute_flag" = true ]; then execute "$file" "$ext" "$file_name"; exit $?; fi
if [ "$interpreter_flag" = true ]; then interpreter "$file" "$ext" "$file_name"; exit $?; fi

