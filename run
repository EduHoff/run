#!/usr/bin/env bash

# -------------------
# Funções utilitárias
# -------------------

find_cargo_toml() {
    local current_dir=$(dirname "$(realpath "$1")")
    while [ "$current_dir" != "/" ] && [ -n "$current_dir" ]; do
        if [ -f "$current_dir/Cargo.toml" ]; then
            echo "$current_dir/Cargo.toml"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done
    return 1
}

# Detectar a classe principal de um projeto Java
detect_main_class() {
    local root_dir="$1"
    local candidates=()

    while IFS= read -r file; do
        if grep -q "public[[:space:]]\+static[[:space:]]\+void[[:space:]]\+main" "$file"; then
            local pkg=$(grep "^package " "$file" | sed 's/package \(.*\);/\1/' || true)
            local cls=$(basename "$file" .java)
            if [ -n "$pkg" ]; then
                candidates+=("$pkg.$cls")
            else
                candidates+=("$cls")
            fi
        fi
    done < <(find "$root_dir" -name "*.java")

    if [ ${#candidates[@]} -eq 0 ]; then
        echo "Error: Nenhuma classe com método main encontrada." >&2
        return 1
    elif [ ${#candidates[@]} -eq 1 ]; then
        echo "${candidates[0]}"
    else
        echo "Foram encontradas várias classes com método main:"
        for i in "${!candidates[@]}"; do
            echo "[$((i+1))] ${candidates[$i]}"
        done
        read -p "Escolha a classe principal (número): " choice
        local index=$((choice-1))
        if [ -n "${candidates[$index]}" ]; then
            echo "${candidates[$index]}"
        else
            echo "Escolha inválida." >&2
            return 1
        fi
    fi
}

# -------------------
# Compilar
# -------------------
compile(){
    local file="$1"
    local ext="$2"
    local file_name="$3"

    case "$ext" in
        "c") gcc "$file" -o "$file_name" ;;
        "cpp") g++ "$file" -o "$file_name" ;;
        "cs")
            if compgen -G "*.csproj" > /dev/null; then
                dotnet build
            else
                echo "Error: C# requires a .csproj project file." >&2
                return 1
            fi
            ;;
        "csproj") dotnet build ;;
        "hs") ghc "$file" -o "$file_name" ;;
        "rs")
            local cargo_toml=$(find_cargo_toml "$file")
            if [ -n "$cargo_toml" ]; then
                (cd "$(dirname "$cargo_toml")" && cargo build)
            else
                rustc "$file"
            fi
            ;;
        "jar")
            echo "JAR file detected. Nothing to compile." ;;
        "java" | "class")
            echo "Error: Java requires the --java flag. Use: run --java <root_dir>" >&2
            return 1
            ;;
        *)
            [ "$compile_flag" = true ] && echo "Error: File '$file' is not compilable." >&2 && return 1
            ;;
    esac
}

# -------------------
# Executar
# -------------------
execute(){
    local file="$1"
    local ext="$2"
    local file_name="$3"

    case "$ext" in
        "c" | "cpp" | "hs") ./"$file_name" ;;
        "cs" | "csproj") dotnet run --no-build ;;
        "rs")
            local cargo_toml=$(find_cargo_toml "$file")
            if [ -n "$cargo_toml" ]; then
                (cd "$(dirname "$cargo_toml")" && cargo run)
            else
                ./"$file_name"
            fi
            ;;
        "jar") java -jar "$file" ;;
        "java" | "class")
            echo "Error: Java requires the --java flag. Use: run --java <root_dir>" >&2
            return 1
            ;;
    esac
}

# -------------------
# Interpretar
# -------------------
interpreter(){
    local file="$1"
    local ext="$2"
    case "$ext" in
        "hs") runhaskell "$file" ;;
        "js" | "ts") node "$file" ;;
        "py") python3 "$file" ;;
        "sh") ./"$file" ;;
        "java" | "class" | "jar")
            echo "Error: Java requires the --java flag. Use: run --java <root_dir>" >&2
            exit 1
            ;;
        *) echo "Error: '$ext' is not an interpreted language." >&2; exit 1 ;;
    esac
}

# -------------------
# Java: compilar e executar
# -------------------

compile_java(){
    local root_dir="$1"

    if [ -f "$root_dir/pom.xml" ]; then
        echo "Maven project detected. Compiling with mvn..."
        (cd "$root_dir" && mvn package)
    elif compgen -G "$root_dir/build.gradle*" > /dev/null; then
        echo "Gradle project detected. Compiling with gradle..."
        (cd "$root_dir" && gradle build)
    else
        echo "Manual Java project detected. Compiling all .java files..."
        find "$root_dir" -name "*.java" > sources.txt
        if [ -s sources.txt ]; then
            mkdir -p "$root_dir/bin"
            javac -d "$root_dir/bin" @sources.txt
            local entry_point
            entry_point=$(detect_main_class "$root_dir") || return 1
            local jar_name="$root_dir/$(basename "$entry_point").jar"
            echo "Main-Class: $entry_point" > "$root_dir/manifest.txt"
            jar cfm "$jar_name" "$root_dir/manifest.txt" -C "$root_dir/bin" .
            rm sources.txt "$root_dir/manifest.txt"
            echo "Created JAR: $jar_name (entry point: $entry_point)"
        else
            echo "Error: No .java files found in $root_dir." >&2
            rm sources.txt
            return 1
        fi
    fi
}

execute_java(){
    local root_dir="$1"

    if [ -f "$root_dir/pom.xml" ]; then
        echo "Running Maven project..."
        (cd "$root_dir" && mvn exec:java)
    elif compgen -G "$root_dir/build.gradle*" > /dev/null; then
        echo "Running Gradle project..."
        (cd "$root_dir" && gradle run)
    else
        local jar_file=$(find "$root_dir" -maxdepth 1 -name "*.jar" | head -n 1)
        if [ -n "$jar_file" ]; then
            echo "Running JAR: $jar_file"
            java -jar "$jar_file"
        else
            echo "Error: No JAR found. Compile first with -c." >&2
            return 1
        fi
    fi
}

interpret_java(){
    local root_dir="$1"
    echo "Running Java classes directly..."
    local entry_point
    entry_point=$(detect_main_class "$root_dir") || return 1
    java -cp "$root_dir/bin" "$entry_point"
}

# -------------------
# Processar flags
# -------------------
compile_flag=false
execute_flag=false
interpreter_flag=false
java_flag=false
java_root=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -c) compile_flag=true; shift ;;
        -e) execute_flag=true; shift ;;
        -i) interpreter_flag=true; shift ;;
        --java) java_flag=true; shift; java_root="$1"; shift ;;
        *) break ;;
    esac
done

# -------------------
# Execução Java
# -------------------
if [ "$java_flag" = true ]; then
    if [ -z "$java_root" ]; then
        echo "Error: No Java root directory provided." >&2
        exit 1
    fi

    [ "$compile_flag" = true ] && compile_java "$java_root"
    [ "$execute_flag" = true ] && execute_java "$java_root"
    [ "$interpreter_flag" = true ] && interpret_java "$java_root"

    # Se não pediu nada, compila e executa
    if [ "$compile_flag" = false ] && [ "$execute_flag" = false ] && [ "$interpreter_flag" = false ]; then
        compile_java "$java_root" && execute_java "$java_root"
    fi
    exit $?
fi

# -------------------
# Execução normal
# -------------------
if [ -z "$1" ]; then
    echo "Error: No input file provided." >&2
    exit 1
fi

file="$1"
ext="${file##*.}"
file_name=$(basename "$file" ."$ext")

if [ "$compile_flag" = false ] && [ "$execute_flag" = false ] && [ "$interpreter_flag" = false ]; then
    compile "$file" "$ext" "$file_name" && execute "$file" "$ext" "$file_name"
    exit $?
fi
[ "$compile_flag" = true ] && compile "$file" "$ext" "$file_name" && exit $?
[ "$execute_flag" = true ] && execute "$file" "$ext" "$file_name" && exit $?
[ "$interpreter_flag" = true ] && interpreter "$file" "$ext" && exit $?

